<!-- Dedicated to God the Father -->
<!-- All Rights Reserved Christopher Andrew Topalian Copyright 2000-2025 -->
<!-- https://github.com/ChristopherTopalian -->
<!-- https://github.com/ChristopherAndrewTopalian -->
<!-- Lumen Super-Structure Visualization.html -->

<!DOCTYPE html>
<html>
<head>
<title>Lumen Super-Structure Visualization</title>
<style>
body
{
    margin: 0;
    background-color: rgb(20, 20, 30);
    overflow: hidden;
}
canvas
{
    display: block;
}
</style>
</head>
<body>
<canvas id="networkCanvas"></canvas>
<script>
/* 4D vector operations */
function Vector4(x, y, z, w)
{
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
}

Vector4.prototype.rotateXY = function(theta)
{
    let cosT = Math.cos(theta);
    let sinT = Math.sin(theta);
    let x = this.x * cosT - this.y * sinT;
    let y = this.x * sinT + this.y * cosT;
    this.x = x;
    this.y = y;
};

Vector4.prototype.rotateZW = function(theta)
{
    let cosT = Math.cos(theta);
    let sinT = Math.sin(theta);
    let z = this.z * cosT - this.w * sinT;
    let w = this.z * sinT + this.w * cosT;
    this.z = z;
    this.w = w;
};

Vector4.prototype.project = function(scale)
{
    let wFactor = 1 / (2 - this.w / scale);
    return {
        x: this.x * wFactor * scale,
        y: this.y * wFactor * scale,
        z: this.z * wFactor * scale
    };
};

/* visual node */
class VisualNode
{
    constructor(name, vec)
    {
        this.name = name;
        this.vec = vec;
        this.connections = [];
    }

    connect(node)
    {
        this.connections.push(node);
    }
}

/* generate a single 4D hypercube */
function generateHypercube(dimension, scale)
{
    let nodes = [];
    let totalNodes = Math.pow(2, dimension);
    for (let i = 0; i < totalNodes; i++)
    {
        let coords = [];
        for (let d = 0; d < dimension; d++)
        {
            coords.push((i >> d) & 1 ? scale : -scale);
        }
        nodes.push(new VisualNode("Node_" + i, new Vector4(coords[0], coords[1], coords[2], coords[3])));
    }

    for (let i = 0; i < totalNodes; i++)
    {
        for (let j = i + 1; j < totalNodes; j++)
        {
            let dist = 0;
            for (let d = 0; d < dimension; d++)
            {
                dist += ((i >> d) & 1) ^ ((j >> d) & 1);
            }
            if (dist === 1)
            {
                nodes[i].connect(nodes[j]);
                nodes[j].connect(nodes[i]);
            }
        }
    }

    return nodes;
}

/* generate multiple hypercubes and interconnect them as super-structures */
function generateSuperNetwork(hypercubeCount, dimension, scale)
{
    let network = [];
    let hypercubes = [];

    for (let i = 0; i < hypercubeCount; i++)
    {
        let cube = generateHypercube(dimension, scale);
        hypercubes.push(cube);
        network = network.concat(cube);
    }

    /* randomly interconnect nodes across hypercubes */
    for (let i = 0; i < hypercubes.length - 1; i++)
    {
        let cubeA = hypercubes[i];
        let cubeB = hypercubes[i + 1];
        for (let j = 0; j < cubeA.length; j++)
        {
            let nodeA = cubeA[j];
            let nodeB = cubeB[Math.floor(Math.random() * cubeB.length)];
            nodeA.connect(nodeB);
            nodeB.connect(nodeA);
        }
    }

    return network;
}

/* canvas setup */
let canvas = document.getElementById("networkCanvas");
let ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
let centerX = canvas.width / 2;
let centerY = canvas.height / 2;

/* create multi-hypercube super-structure: 5 hypercubes */
let superNodes = generateSuperNetwork(5, 4, 80);

/* animate and rotate */
function animate()
{
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < superNodes.length; i++)
    {
        superNodes[i].vec.rotateXY(0.01);
        superNodes[i].vec.rotateZW(0.008);
    }

    /* draw connections */
    ctx.strokeStyle = "rgba(50, 200, 250, 0.6)";
    for (let i = 0; i < superNodes.length; i++)
    {
        let node = superNodes[i];
        let p1 = node.vec.project(200);
        for (let j = 0; j < node.connections.length; j++)
        {
            let p2 = node.connections[j].vec.project(200);
            ctx.beginPath();
            ctx.moveTo(centerX + p1.x, centerY + p1.y);
            ctx.lineTo(centerX + p2.x, centerY + p2.y);
            ctx.stroke();
        }
    }

    /* draw nodes */
    for (let i = 0; i < superNodes.length; i++)
    {
        let p = superNodes[i].vec.project(200);
        ctx.beginPath();
        ctx.arc(centerX + p.x, centerY + p.y, 4, 0, 2 * Math.PI);
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fill();
    }

    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
