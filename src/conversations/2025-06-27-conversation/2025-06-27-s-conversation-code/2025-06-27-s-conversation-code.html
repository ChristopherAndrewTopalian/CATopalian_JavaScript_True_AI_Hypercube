<!-- Dedicated to God the Father -->
<!-- All Rights Reserved Christopher Andrew Topalian Copyright 2000-2025 -->
<!-- https://github.com/ChristopherTopalian -->
<!-- https://github.com/ChristopherAndrewTopalian -->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title> CATopalian True AI Hypercube Prototype </title>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body style="margin:0; overflow:hidden;">
<canvas id="renderCanvas"></canvas>
<script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);

    // Camera & Light
    const camera = new BABYLON.ArcRotateCamera("cam", Math.PI / 2.3, Math.PI / 3, 30, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

    // Logic groups color map
    const gateColors = {
        core: new BABYLON.Color3(1.0, 0.2, 0.6),
        groupGreen: new BABYLON.Color3(0.2, 1.0, 0.2),
        groupOrange: new BABYLON.Color3(1.0, 0.6, 0.2),
        groupBlue: new BABYLON.Color3(0.2, 0.6, 1.0)
    };

    // Utility to create material
    function mat(color) {
        const m = new BABYLON.StandardMaterial("", scene);
        m.emissiveColor = color;
        return m;
    }

    const matCore = mat(gateColors.core);
    const matGreen = mat(gateColors.groupGreen);
    const matOrange = mat(gateColors.groupOrange);
    const matBlue = mat(gateColors.groupBlue);

    const radius = 8;
    const nodeCount = 56;
    const faceOffset = 10;

    // Helper to map node index to color group
    function pickMaterial(i) {
        // example distribution; adjust as needed
        if (i % 3 === 0) return matGreen;
        if (i % 3 === 1) return matOrange;
        return matBlue;
    }

    // Create one circular face of 56 nodes at Z = offset
    function createFace(z) {
        const nodes = [];
        for (let i = 0; i < nodeCount; i++) {
            const angle = (Math.PI * 2 / nodeCount) * i;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const sphere = BABYLON.MeshBuilder.CreateSphere("node" + z + "_" + i, { diameter: 0.4 }, scene);
            sphere.position.set(x, y, z);
            sphere.material = pickMaterial(i);
            nodes.push(sphere);
        }
        return nodes;
    }

    const bottomNodes = createFace(-faceOffset);
    const topNodes = createFace(+faceOffset);

    // Central core node
    const core = BABYLON.MeshBuilder.CreateSphere("core", { diameter: 0.7 }, scene);
    core.position.set(0, 0, 0);
    core.material = matCore;

    // Connect vertical pillars bottomâ†’top for each of the 56 nodes
    function connectPillar(bottom, top, matColor) {
        const line = BABYLON.MeshBuilder.CreateCylinder("pill", { diameter: 0.08, height: faceOffset * 2 }, scene);
        const mid = BABYLON.Vector3.Center(bottom.position, top.position);
        line.position = mid;
        line.rotationQuaternion = BABYLON.Quaternion.FromLookDirectionLH(
            top.position.subtract(bottom.position).normalize(),
            BABYLON.Vector3.Up()
        );
        line.material = matColor;
    }

    for (let i = 0; i < nodeCount; i++) {
        connectPillar(bottomNodes[i], topNodes[i], pickMaterial(i));
    }

    // Connect center core to both faces with thicker pillars
    function connectCore(faceNode, matColor) {
        const cyl = BABYLON.MeshBuilder.CreateCylinder("core_p", { diameter: 0.12, height: faceOffset }, scene);
        const midZ = (faceNode.position.z + core.position.z) / 2;
        cyl.position.set(faceNode.position.x * 0.1, faceNode.position.y * 0.1, midZ);
        cyl.rotationQuaternion = BABYLON.Quaternion.FromLookDirectionLH(
            core.position.subtract(faceNode.position).normalize(),
            BABYLON.Vector3.Up()
        );
        cyl.material = matCore;
    }

    // Connect every sixth node to core as example
    for (let i = 0; i < nodeCount; i += 6) {
        connectCore(topNodes[i], matCore);
        connectCore(bottomNodes[i], matCore);
    }

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>

